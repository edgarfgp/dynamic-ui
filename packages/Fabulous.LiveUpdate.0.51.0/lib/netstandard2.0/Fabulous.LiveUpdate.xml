<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Fabulous.LiveUpdate</name></assembly>
<members>
<member name="T:FSharp.Compiler.PortaCode.CodeModel.DExpr">
<summary>
 A representation of resolved F# expressions that can be serialized
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.EvalContext.TryEvalDecls(FSharp.Compiler.PortaCode.Interpreter.Env,FSharp.Compiler.PortaCode.CodeModel.DDecl[],Microsoft.FSharp.Core.FSharpOption{System.Boolean})">
<summary>
 Try to evaluate the declarations, collecting errors and optimisitically continuing
 as we go.  Optionally evaluate only the ones marked with the [&lt;LiveCheck&gt;] attribute,
 in which case execution is done on-demand.
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.EvalContext.ResolveMethod(FSharp.Compiler.PortaCode.CodeModel.DMemberRef)">
<summary>
 Resolve a method name to a lambda value
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.EvalContext.ResolveEntity(FSharp.Compiler.PortaCode.CodeModel.DEntityRef)">
<summary>
 Resolve an F# entity (type or module)
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.EvalContext.EvalDecls(FSharp.Compiler.PortaCode.Interpreter.Env,FSharp.Compiler.PortaCode.CodeModel.DDecl[])">
<summary>
 Evalaute all the declarations using regular F# semantics
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.EvalContext.AddDecls(FSharp.Compiler.PortaCode.CodeModel.DDecl[])">
<summary>
 Add the declarations for the types and methods
</summary>
</member>
<member name="T:FSharp.Compiler.PortaCode.Interpreter.EvalContext">
<summary>
 Context for evaluation/interpretation
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.Sink.UseLocal(FSharp.Compiler.PortaCode.CodeModel.DLocalRef,FSharp.Compiler.PortaCode.Interpreter.Value)">
<summary>
 Called whenever a local is used
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.Sink.CallAndReturn(FSharp.Compiler.PortaCode.CodeModel.DMemberRef,FSharp.Compiler.PortaCode.CodeModel.DMemberDef,System.Type[],System.Object[],FSharp.Compiler.PortaCode.Interpreter.Value)">
<summary>
 Called whenever a call is completed
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.Sink.BindValue(FSharp.Compiler.PortaCode.CodeModel.DMemberDef,FSharp.Compiler.PortaCode.Interpreter.Value)">
<summary>
 Called whenever a value in a module is computed
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.Sink.BindLocal(FSharp.Compiler.PortaCode.CodeModel.DLocalDef,FSharp.Compiler.PortaCode.Interpreter.Value)">
<summary>
 Called whenever a parameter is bound or a local is computed
</summary>
</member>
<member name="T:FSharp.Compiler.PortaCode.Interpreter.Sink">
<summary>
 A sink to report operation of the interpreter
</summary>
</member>
<member name="M:FSharp.Compiler.PortaCode.Interpreter.protectEval``1(System.Boolean,Microsoft.FSharp.Core.FSharpOption{FSharp.Compiler.PortaCode.CodeModel.DRange},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 If an exception happens, record the range in the exception
</summary>
</member>
<member name="M:Fabulous.LiveUpdate.Extensions.enableLiveUpdate``3(Microsoft.FSharp.Core.FSharpFunc{Fabulous.LiveUpdate.BroadcasterAddress[],Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.Unit},Fabulous.ProgramRunner{``0,``1,``2})">
<summary>
 Starts the HttpServer listening for changes
</summary>
</member>
<member name="T:Fabulous.LiveUpdate.Extensions">
<summary>
 Program module - functions to manipulate program instances
</summary>
</member>
</members>
</doc>
